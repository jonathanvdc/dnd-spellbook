{"version":3,"sources":["spell.ts","SpellCard.tsx","SpellLink.tsx","Spellbook.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["getSpellThumbnailUrl","spell","name","SpellCard","components","this","props","verbal","push","somatic","material","className","casting_time","range","join","duration","key","value","elems","materials_needed","createFactFootnote","classes","description","split","elem","length","src","alt","type","createPropertiesGrid","createDescription","createFootnotes","Component","SpellLink","to","sortedLevels","sortBy","list","getKey","sort","a","b","x","y","Spellbook","spellsByLevel","level","spells","levelName","s","map","bins","Map","bin","get","set","levelSpellPairs","allSpells","App","state","fetch","then","response","json","setState","exact","path","component","MainScreenRouter","SpellRoute","find","val","match","params","spellName","Boolean","window","location","hostname","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.0fb8be4d.chunk.js","sourcesContent":["export type Class =\n    \"barbarian\" | \"bard\" | \"cleric\"\n    | \"druid\" | \"fighter\" | \"monk\"\n    | \"paladin\" | \"ranger\" | \"rogue\"\n    | \"warlock\" | \"sorcerer\" | \"wizard\";\n\n/**\n * The components required to cast a spell.\n */\nexport type SpellComponents = {\n    /**\n     * Tells if the spell has any material components.\n     */\n    material: boolean;\n    /**\n     * A list of materials needed to cast the spell.\n     */\n    materials_needed?: string[];\n    /**\n     * A raw description of a spell's components, formatted\n     * as a string.\n     */\n    raw: string;\n    /**\n     * Tells if a spell has a somatic component.\n     */\n    somatic: boolean;\n    /**\n     * Tells if a spell has a verbal component.\n     */\n    verbal: boolean;\n};\n\nexport type SpellLevel = \"cantrip\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\";\n\nexport type School = \"abjuration\" | \"conjuration\" | \"divination\" | \"enchantment\"\n    | \"evocation\" | \"illusion\" | \"necromancy\" | \"transmutation\";\n\n/**\n * Gets a URL to a particular spell's thumbnail.\n * @param spell The spell to find a thumbnail for.\n */\nexport function getSpellThumbnailUrl(spell: Spell): string {\n    const imageUrlPrefix = \"https://raw.githubusercontent.com/iconsheets/iconsheets.github.io/master/Images/\";\n    return imageUrlPrefix + spell.name + \".png\";\n}\n\n/**\n * A description of a spell.\n */\nexport type Spell = {\n    /**\n     * The amount of time it takes to cast the spell.\n     */\n    casting_time: string;\n\n    /**\n     * A list of all classes that can cast the spell.\n     */\n    classes: Class[];\n\n    /**\n     * The spell's components.\n     */\n    components: SpellComponents;\n\n    /**\n     * A description of the spell's effect.\n     */\n    description: string;\n\n    /**\n     * A description of the spell's duration.\n     */\n    duration: string;\n\n    /**\n     * The spell's level.\n     */\n    level: SpellLevel;\n\n    /**\n     * The spell's name.\n     */\n    name: string;\n\n    /**\n     * The spell's range.\n     */\n    range: string;\n\n    /**\n     * Tells if the spell can be cast as a ritual.\n     */\n    ritual: boolean;\n\n    /**\n     * The school of magic to which the spell belongs.\n     */\n    school: School;\n\n    /**\n     * A list of tags.\n     */\n    tags: string[];\n\n    /**\n     * The spell's type.\n     */\n    type: string;\n};\n","import React, { Component } from \"react\";\nimport { Spell, getSpellThumbnailUrl } from \"./spell\";\nimport \"./SpellCard.css\";\nimport \"./hr.css\";\n\ntype Props = {\n    spell: Spell;\n};\n\n/**\n * A card that describes a spell.\n */\nclass SpellCard extends Component<Props, {}> {\n    /**\n     * Create a \"quick stats\" grid to include in the card.\n     */\n    createPropertiesGrid() {\n        let components = [];\n        if (this.props.spell.components.verbal) {\n            components.push(\"V\");\n        }\n        if (this.props.spell.components.somatic) {\n            components.push(\"S\");\n        }\n        if (this.props.spell.components.material) {\n            components.push(\"M\");\n        }\n        return <div className=\"SpellPropertiesGrid\">\n            <div className=\"SpellPropertyItem\">\n                <div className=\"SpellPropertyItemName\">Casting time</div>\n                <div>{this.props.spell.casting_time}</div>\n            </div>\n            <div className=\"SpellPropertyItem\">\n                <div className=\"SpellPropertyItemName\">Range</div>\n                <div>{this.props.spell.range}</div>\n            </div>\n            <div className=\"SpellPropertyItem\">\n                <div className=\"SpellPropertyItemName\">Components</div>\n                <div>{components.join(\", \")}</div>\n            </div>\n            <div className=\"SpellPropertyItem\">\n                <div className=\"SpellPropertyItemName\">Duration</div>\n                <div>{this.props.spell.duration}</div>\n            </div>\n        </div>;\n    }\n\n    createFactFootnote(key: string, value: string) {\n        return <div className=\"SpellFootnote\"><span className=\"SpellPropertyItemName\">{key}:</span> {value}</div>;\n    }\n\n    /**\n     * Creates an \"additional facts\" sheet, which is essentially a collection\n     * of footnotes.\n     */\n    createFootnotes(): JSX.Element[] {\n        let elems: JSX.Element[] = [];\n        if (this.props.spell.components.materials_needed) {\n            elems.push(this.createFactFootnote(\"Materials\", this.props.spell.components.materials_needed.join(\"; \")));\n        }\n        elems.push(this.createFactFootnote(\"Classes\", this.props.spell.classes.join(\", \")));\n        return elems;\n    }\n\n    /**\n     * Creates a textual description of the spell.\n     */\n    createDescription(): JSX.Element {\n        let elems = [];\n        for (let elem of this.props.spell.description.split(\"\\\\n\")) {\n            if (elems.length > 0) {\n                elems.push(<br/>);\n            }\n            elems.push(elem);\n        }\n        return <p className=\"SpellDescription\">{elems}</p>;\n    }\n\n    render() {\n        return <div className=\"SpellCardPanel\">\n            <img className=\"SpellThumbnail\" src={getSpellThumbnailUrl(this.props.spell)} alt={this.props.spell.name + \" thumbnail\"} />\n            <div className=\"SpellType\">{this.props.spell.type}</div>\n            <div className=\"SpellName\">{this.props.spell.name}</div>\n            <hr/>\n            {this.createPropertiesGrid()}\n            <hr/>\n            {this.createDescription()}\n            <hr/>\n            {this.createFootnotes()}\n        </div>;\n    }\n}\n\nexport default SpellCard;\n","import React, { Component } from \"react\";\nimport { Spell, getSpellThumbnailUrl } from \"./spell\";\nimport { Link } from \"react-router-dom\";\nimport './SpellLink.css';\n\n/**\n * A reference to a spell, formatted as an image.\n */\nclass SpellLink extends Component<{spell: Spell}, {}> {\n    render() {\n        return <Link className=\"SpellLink\" to={`/spell/${this.props.spell.name}`}>\n            <img src={getSpellThumbnailUrl(this.props.spell)} alt={this.props.spell.name + \" thumbnail\"} />\n            <div>{this.props.spell.name}</div>\n        </Link>;\n    }\n}\n\nexport default SpellLink;\n","import React, { Component } from \"react\";\nimport { Spell, SpellLevel } from \"./spell\";\nimport \"./Spellbook.css\";\nimport \"./hr.css\";\nimport SpellLink from \"./SpellLink\";\n\nconst sortedLevels: SpellLevel[] = [\"cantrip\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"];\n\nfunction sortBy<T>(list: T[], getKey: (val: T) => any): T[] {\n    return list.sort((a, b) => {\n        let x = getKey(a);\n        let y = getKey(b);\n        return +(x > y) - +(y > x);\n    });\n}\n\n/**\n * A component that displays a sequence of spells.\n */\nclass Spellbook extends Component<{ spells: Spell[] }, any> {\n    render() {\n        let elems = [];\n        for (let { level, spells } of this.spellsByLevel()) {\n            let levelName = level === \"cantrip\" ? \"Cantrips\" : `Level ${level} spells`;\n            elems.push(<div><hr/>{levelName}<hr/></div>);\n            elems.push(<div className=\"SpellList\">{sortBy(spells, s => s.name).map(spell => <SpellLink spell={spell}/>)}</div>);\n        }\n        return <div className=\"SpellbookPanel\">{elems}</div>;\n    }\n\n    private spellsByLevel() {\n        let bins = new Map<string, Spell[]>();\n        for (let spell of this.props.spells) {\n            let bin = bins.get(spell.level);\n            if (!bin) {\n                bin = [];\n                bins.set(spell.level, bin);\n            }\n            bin.push(spell);\n        }\n\n        let levelSpellPairs: { level: string, spells: Spell[] }[] = [];\n        for (let level of sortedLevels) {\n            let spells = bins.get(level);\n            if (spells) {\n                levelSpellPairs.push({ level, spells });\n            }\n        }\n        return levelSpellPairs;\n    }\n}\n\nexport default Spellbook;\n","import React, { Component } from 'react';\nimport { Route, HashRouter } from 'react-router-dom';\nimport './App.css';\nimport { Spell } from './spell';\nimport SpellCard from './SpellCard';\nimport Spellbook from './Spellbook';\n\nlet allSpells: Spell[] = [];\n\nclass App extends Component<{}, Spell[]> {\n  constructor(props: {}) {\n    super(props);\n    this.state = allSpells;\n  }\n\n  componentDidMount() {\n    // Fetch spell database from third-party GitHub repository.\n    fetch(\"https://raw.githubusercontent.com/iconsheets/iconsheets.github.io/master/Database/SpellDatabase.json\")\n    .then(response => response.json())\n    .then(json => {\n      allSpells = json;\n      this.setState(json);\n    });\n  }\n\n  render() {\n    return (\n      <HashRouter>\n        <div className=\"App\">\n          <header className=\"App-header\">\n            <Route exact={true} path=\"/\" component={MainScreenRouter} />\n            <Route path=\"/spell/:spellName\" component={SpellRoute} />\n          </header>\n        </div>\n      </HashRouter>\n    );\n  }\n}\n\nclass MainScreenRouter extends Component<{ match: any }, any> {\n  render() {\n    return <Spellbook spells={allSpells}/>;\n  }\n}\n\nclass SpellRoute extends Component<{ match: any }, any> {\n  render() {\n    if (allSpells.length === 0) {\n      return <div></div>;\n    }\n    let spell = allSpells.find((val => val.name === this.props.match.params.spellName));\n    if (spell) {\n      return <SpellCard spell={spell} />;\n    } else {\n      return <div><h1>Error 404</h1>Spell '{this.props.match.params.spellName}' not found.</div>;\n    }\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}