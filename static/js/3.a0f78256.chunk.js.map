{"version":3,"sources":["../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","model/spell-linter.ts","LinterResults.tsx"],"names":["_toConsumableArray","arr","Array","isArray","i","arr2","length","iter","Symbol","iterator","Object","prototype","toString","call","from","TypeError","checks","spell","hasMatsDesc","components","materials_needed","material","severity","message","source","LinterResults","diagnostics","spells","results","check","push","lint","this","props","errorList","className","map","d","to","createSpellUrl","name","PureComponent"],"mappings":"8MAGe,SAASA,EAAmBC,GACzC,OCJa,SAA4BA,GACzC,GAAIC,MAAMC,QAAQF,GAAM,CACtB,IAAK,IAAIG,EAAI,EAAGC,EAAO,IAAIH,MAAMD,EAAIK,QAASF,EAAIH,EAAIK,OAAQF,IAC5DC,EAAKD,GAAKH,EAAIG,GAGhB,OAAOC,GDFF,CAAkBJ,IEJZ,SAA0BM,GACvC,GAAIC,OAAOC,YAAYC,OAAOH,IAAkD,uBAAzCG,OAAOC,UAAUC,SAASC,KAAKN,GAAgC,OAAOL,MAAMY,KAAKP,GFGvF,CAAgBN,IGJpC,WACb,MAAM,IAAIc,UAAU,mDHGqC,GI0C3D,IAAMC,EAAyB,CAQ/B,SAAgCC,GAC5B,IAAIC,EAAcD,EAAME,WAAWC,kBAAoBH,EAAME,WAAWC,iBAAiBd,OAAS,EAClG,OAAIW,EAAME,WAAWE,WAAaH,EACvB,CACH,CACII,SAAU,QACVC,QAAS,oGACTC,OAAQP,KAGRA,EAAME,WAAWE,UAAYH,EAC9B,CACH,CACII,SAAU,QACVC,QAAS,0GACTC,OAAQP,IAIT,K,oBC/DTQ,G,wLAEE,IAAIC,EDqBL,SAAcC,GACjB,IAAIC,EAA+B,GADoB,uBAEvD,YAAkBD,EAAlB,+CAA0B,CAAC,IAAlBV,EAAiB,+BACtB,YAAkBD,EAAlB,+CAA0B,CAAC,IAAlBa,EAAiB,QACtBD,EAAQE,KAAR,MAAAF,EAAO,EAASC,EAAMZ,MAFJ,oFAF6B,kFAOvD,OAAOW,EC5BeG,CAAKC,KAAKC,MAAMN,QAC9BO,EAAmC,IAAvBR,EAAYpB,OACtB,uCACA,wBAAI6B,UAAU,wBACXT,EAAYU,IAAI,SAAAC,GAAC,OAAI,4BAAI,kBAAC,IAAD,CAAMC,GAAIC,YAAeF,EAAEb,SAAUa,EAAEb,OAAOgB,MAAlD,KAAgE,2BAAIH,EAAEf,SAAN,KAAhE,IAAsFe,EAAEd,YAEtH,OAAO,6BACH,8CACCW,O,GAVeO,kBAebhB","file":"static/js/3.a0f78256.chunk.js","sourcesContent":["import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}","export default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}","export default function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}","import { Spell } from \"./spell\";\n\n/**\n * A description of a diagnostic's severity.\n */\nexport type Severity = \"error\" | \"warning\";\n\n/**\n * A diagnostic: a message produced by a linter.\n */\nexport type Diagnostic<T> = {\n    /**\n     * The diagnostic's severity.\n     */\n    severity: Severity;\n    /**\n     * The diagnostic's message.\n     */\n    message: string;\n    /**\n     * The value that gave rise to the diagnostic.\n     */\n    source: T;\n};\n\ntype Check<T> = (source: T) => Diagnostic<T>[];\n\n/**\n * Takes a sequence of spells and applies a number of checks to\n * ensure that the spells are well-formed. Results are returned\n * as a list of diagnostics.\n * @param spells A sequence of spells to process.\n */\nexport function lint(spells: Spell[]): Diagnostic<Spell>[] {\n    let results: Diagnostic<Spell>[] = [];\n    for (let spell of spells) {\n        for (let check of checks) {\n            results.push(...check(spell));\n        }\n    }\n    return results;\n}\n\n/**\n * An enumeration of all checks available to the linter.\n */\nconst checks: Check<Spell>[] = [\n    materialsAreConsistent\n];\n\n/**\n * Checks that a spell's materials description is consistent.\n * @param spell A spell to check.\n */\nfunction materialsAreConsistent(spell: Spell): Diagnostic<Spell>[] {\n    let hasMatsDesc = spell.components.materials_needed && spell.components.materials_needed.length > 0;\n    if (spell.components.material && !hasMatsDesc) {\n        return [\n            {\n                severity: \"error\",\n                message: \"spell states that it requires materials but does not list any in its 'materials_needed' property.\",\n                source: spell\n            }\n        ];\n    } else if (!spell.components.material && hasMatsDesc) {\n        return [\n            {\n                severity: \"error\",\n                message: \"spell states that it does not require materials but lists materials in its 'materials_needed' property.\",\n                source: spell\n            }\n        ];\n    } else {\n        return [];\n    }\n}\n","import React, { PureComponent } from \"react\";\nimport { Spell } from \"./model/spell\";\nimport { lint } from \"./model/spell-linter\";\nimport { Link } from \"react-router-dom\";\nimport { createSpellUrl } from \"./SpellLink\";\nimport \"./LinterResults.css\";\n\n/**\n * A component that displays linter results for spells.\n */\nclass LinterResults extends PureComponent<{ spells: Spell[] }> {\n    render() {\n        let diagnostics = lint(this.props.spells);\n        let errorList = diagnostics.length === 0\n            ? \"Nothing to report. Have a great day!\"\n            : <ul className=\"LinterDiagnosticList\">\n                {diagnostics.map(d => <li><Link to={createSpellUrl(d.source)}>{d.source.name}</Link>: <b>{d.severity}:</b> {d.message}</li>)}\n            </ul>;\n        return <div>\n            <h1>Linter results</h1>\n            {errorList}\n        </div>;\n    }\n}\n\nexport default LinterResults;\n"],"sourceRoot":""}