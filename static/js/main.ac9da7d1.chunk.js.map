{"version":3,"sources":["model/spell.ts","SpellCard.tsx","SpellLink.tsx","Spellbook.tsx","FilterableSpellbook.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["allClasses","getSpellThumbnailUrl","spell","thumbnail_url","school","sortedLevels","sortedSchools","sortBy","list","getKey","sort","a","b","x","y","groupBy","sortedGroups","bins","Map","value","key","bin","get","set","push","levelSpellPairs","values","spellsBySchool","spells","s","name","map","getSpellId","whitelist","enc","dash","toLowerCase","c","test","SpellCard","components","this","props","verbal","somatic","material","className","casting_time","range","join","duration","elems","materials_needed","createFactFootnote","classes","hide_links","children","to","href","description","updatedDesc","replace","renderers","link","renderLink","bind","source","baseDesc","formatDescription","higher_levels","thumbnailUrl","src","alt","type","createPropertiesGrid","createDescription","createFootnotes","Component","SpellLink","spellLink","linkImage","isMobile","options","followCursor","shiftX","shiftY","Trigger","Hover","Spellbook","headerClass","isFirefox","level","spellsByLevel","levelSpells","levelName","spellListItems","first","item","height","once","localStorageKey","FilterableSpellbook","savedState","localStorage","getItem","state","JSON","parse","setState","setItem","stringify","newClasses","filter","includes","updateClasses","val","length","some","usefulClasses","ToggleButtonGroup","onChange","vals","toggleClass","ToggleButton","getFilteredSpells","allSpells","App","fetch","then","response","json","exact","path","component","MainScreenRouter","SpellRoute","find","match","params","spellId","thumbStyle","width","style","transform","Boolean","window","location","hostname","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.ac9da7d1.chunk.js","sourcesContent":["export type Class =\n    \"barbarian\" | \"bard\" | \"cleric\"\n    | \"druid\" | \"fighter\" | \"monk\"\n    | \"paladin\" | \"ranger\" | \"rogue\"\n    | \"sorcerer\" | \"warlock\" | \"wizard\";\n\nexport const allClasses: Class[] = [\n    \"barbarian\", \"bard\", \"cleric\",\n    \"druid\", \"fighter\", \"monk\",\n    \"paladin\", \"ranger\", \"rogue\",\n    \"sorcerer\", \"warlock\", \"wizard\"\n];\n\n/**\n * The components required to cast a spell.\n */\nexport type SpellComponents = {\n    /**\n     * Tells if the spell has any material components.\n     */\n    material: boolean;\n    /**\n     * A list of materials needed to cast the spell.\n     */\n    materials_needed?: string[];\n    /**\n     * A raw description of a spell's components, formatted\n     * as a string.\n     */\n    raw: string;\n    /**\n     * Tells if a spell has a somatic component.\n     */\n    somatic: boolean;\n    /**\n     * Tells if a spell has a verbal component.\n     */\n    verbal: boolean;\n};\n\nexport type SpellLevel = \"cantrip\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\";\n\nexport type School = \"abjuration\" | \"conjuration\" | \"divination\" | \"enchantment\"\n    | \"evocation\" | \"illusion\" | \"necromancy\" | \"transmutation\";\n\n/**\n * Gets a URL to a particular spell's thumbnail.\n * @param spell The spell to find a thumbnail for.\n */\nexport function getSpellThumbnailUrl(spell: Spell): string {\n    if (spell.thumbnail_url) {\n        return spell.thumbnail_url;\n    } else {\n        // If we don't have a thumbnail for the spell, then we'll\n        // just create a URL that points to the school's thumbnail.\n        return `images/schools/${spell.school}.svg`;\n    }\n}\n\nconst sortedLevels: SpellLevel[] = [\"cantrip\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"];\nconst sortedSchools: School[] = [\n    \"abjuration\", \"conjuration\", \"divination\", \"enchantment\",\n    \"evocation\", \"illusion\", \"necromancy\", \"transmutation\"\n];\n\nfunction sortBy<T>(list: T[], getKey: (val: T) => any): T[] {\n    return list.sort((a, b) => {\n        let x = getKey(a);\n        let y = getKey(b);\n        return +(x > y) - +(y > x);\n    });\n}\n\nfunction groupBy<T, TKey>(\n    list: T[],\n    sortedGroups: TKey[],\n    getKey: (val: T) => TKey):\n    { key: TKey, values: T[] }[] {\n\n    let bins = new Map<TKey, T[]>();\n    for (let value of list) {\n        let key = getKey(value);\n        let bin = bins.get(key);\n        if (!bin) {\n            bin = [];\n            bins.set(key, bin);\n        }\n        bin.push(value);\n    }\n\n    let levelSpellPairs: { key: TKey, values: T[] }[] = [];\n    for (let key of sortedGroups) {\n        let values = bins.get(key);\n        if (values) {\n            levelSpellPairs.push({ key, values });\n        }\n    }\n    return levelSpellPairs;\n}\n\n/**\n * Groups a list of spells by level.\n * @param spells A list of spells to group.\n */\nexport function spellsByLevel(spells: Spell[]): { level: SpellLevel, spells: Spell[] }[] {\n    return groupBy(sortBy(spells, s => s.name), sortedLevels, s => s.level)\n        .map(({ key, values }) => ({ level: key, spells: values }));\n}\n\n/**\n * Groups a list of spells by school.\n * @param spells A list of spells to group.\n */\nexport function spellsBySchool(spells: Spell[]): { school: School, spells: Spell[] }[] {\n    return groupBy(sortBy(spells, s => s.name), sortedSchools, s => s.school)\n        .map(({ key, values }) => ({ school: key, spells: values }));\n}\n\n/**\n * A description of a spell's source.\n */\nexport type SpellSource = {\n    /**\n     * The document in which the spell was originally described.\n     */\n    document: string;\n\n    /**\n     * The pages in the document that describe the spell.\n     */\n    pages?: string;\n};\n\n/**\n * A description of a spell.\n */\nexport type Spell = {\n    /**\n     * The amount of time it takes to cast the spell.\n     */\n    casting_time: string;\n\n    /**\n     * A list of all classes that can cast the spell.\n     */\n    classes: Class[];\n\n    /**\n     * The spell's components.\n     */\n    components: SpellComponents;\n\n    /**\n     * A description of the spell's effect.\n     */\n    description: string;\n\n    /**\n     * An optional description of what the spell does at higher levels.\n     */\n    higher_levels?: string;\n\n    /**\n     * A description of the spell's duration.\n     */\n    duration: string;\n\n    /**\n     * The spell's level.\n     */\n    level: SpellLevel;\n\n    /**\n     * The spell's name.\n     */\n    name: string;\n\n    /**\n     * The spell's range.\n     */\n    range: string;\n\n    /**\n     * Tells if the spell can be cast as a ritual.\n     */\n    ritual: boolean;\n\n    /**\n     * The school of magic to which the spell belongs.\n     */\n    school: School;\n\n    /**\n     * A list of tags.\n     */\n    tags: string[];\n\n    /**\n     * The spell's type.\n     */\n    type: string;\n\n    /**\n     * An optional URL to the spell's thumbnail.\n     */\n    thumbnail_url?: string;\n\n    /**\n     * An optional accent color for the spell.\n     */\n    accent_color?: string;\n\n    /**\n     * The document in which the spell was originally described.\n     */\n    source?: SpellSource;\n};\n\n/**\n * Gets an identifier for a spell that is safe for use in a URL.\n * @param spell The spell to get an identifier for.\n */\nexport function getSpellId(spell: Spell): string {\n    let name = spell.name;\n    const whitelist = /[0-9a-zA-Z]/;\n    let enc = '';\n    let dash = false;\n    for (let c of name.toLowerCase()) {\n        if (whitelist.test(c)) {\n            enc += c;\n            dash = false;\n        } else if (!dash) {\n            enc += '-';\n            dash = true;\n        }\n    }\n    return enc;\n}\n","import React, { Component } from \"react\";\nimport { Spell, getSpellThumbnailUrl } from \"./model/spell\";\nimport ReactMarkdown from \"react-markdown\";\nimport { Link } from \"react-router-dom\";\nimport \"./SpellCard.css\";\nimport \"./hr.css\";\n\ntype Props = {\n    spell: Spell;\n    hide_links?: boolean;\n};\n\n/**\n * A card that describes a spell.\n */\nclass SpellCard extends Component<Props, {}> {\n    /**\n     * Create a \"quick stats\" grid to include in the card.\n     */\n    createPropertiesGrid() {\n        let components = [];\n        if (this.props.spell.components.verbal) {\n            components.push(\"V\");\n        }\n        if (this.props.spell.components.somatic) {\n            components.push(\"S\");\n        }\n        if (this.props.spell.components.material) {\n            components.push(\"M\");\n        }\n        return <div className=\"SpellPropertiesGrid\">\n            <div className=\"SpellPropertyItem\">\n                <div className=\"SpellPropertyItemName\">Casting time</div>\n                <div>{this.props.spell.casting_time}</div>\n            </div>\n            <div className=\"SpellPropertyItem\">\n                <div className=\"SpellPropertyItemName\">Range</div>\n                <div>{this.props.spell.range}</div>\n            </div>\n            <div className=\"SpellPropertyItem\">\n                <div className=\"SpellPropertyItemName\">Components</div>\n                <div>{components.join(\", \")}</div>\n            </div>\n            <div className=\"SpellPropertyItem\">\n                <div className=\"SpellPropertyItemName\">Duration</div>\n                <div>{this.props.spell.duration}</div>\n            </div>\n        </div>;\n    }\n\n    createFactFootnote(key: string, value: string) {\n        return <div className=\"SpellFootnote\"><span className=\"SpellPropertyItemName\">{key}:</span> {value}</div>;\n    }\n\n    /**\n     * Creates an \"additional facts\" sheet, which is essentially a collection\n     * of footnotes.\n     */\n    createFootnotes(): JSX.Element[] {\n        let elems: JSX.Element[] = [];\n        if (this.props.spell.components.materials_needed) {\n            elems.push(this.createFactFootnote(\"Materials\", this.props.spell.components.materials_needed.join(\"; \")));\n        }\n        elems.push(this.createFactFootnote(\"Classes\", this.props.spell.classes.join(\", \")));\n        return elems;\n    }\n\n    private renderLink(props: { href: string, title: string, children: any[] }) {\n        if (this.props.hide_links) {\n            return <span>{props.children}</span>;\n        } else {\n            return <Link to={props.href}>{props.children}</Link>;\n        }\n    }\n\n    private formatDescription(description: string): JSX.Element {\n        let updatedDesc = description.replace(/\\\\n/g, \"\\n\");\n        let renderers = {\n            link: this.renderLink.bind(this)\n        };\n        return <ReactMarkdown className=\"SpellDescription\" source={updatedDesc} renderers={renderers} />;\n    }\n\n    /**\n     * Creates a textual description of the spell.\n     */\n    createDescription(): JSX.Element {\n        let baseDesc = this.formatDescription(this.props.spell.description);\n        if (this.props.spell.higher_levels) {\n            return <div>\n                {baseDesc}\n                <hr/>\n                {this.formatDescription(this.props.spell.higher_levels)}\n            </div>;\n        } else {\n            return baseDesc;\n        }\n    }\n\n    render() {\n        let thumbnailUrl = getSpellThumbnailUrl(this.props.spell);\n        return <div className=\"SpellCardPanel\">\n            <img className=\"SpellThumbnail\" src={thumbnailUrl} alt={this.props.spell.name + \" thumbnail\"} />\n            <div className=\"SpellType\">{this.props.spell.type}</div>\n            <div className=\"SpellName\">{this.props.spell.name}</div>\n            <hr/>\n            {this.createPropertiesGrid()}\n            <hr/>\n            {this.createDescription()}\n            <hr/>\n            {this.createFootnotes()}\n        </div>;\n    }\n}\n\nexport default SpellCard;\n","import React, { Component } from \"react\";\nimport { Link } from \"react-router-dom\";\nimport { isMobile } from \"react-device-detect\";\nimport ReactHover from \"react-hover\";\nimport Tilt from \"react-tilt\";\nimport { Spell, getSpellThumbnailUrl, getSpellId } from \"./model/spell\";\nimport './SpellLink.css';\nimport SpellCard from \"./SpellCard\";\n\n/**\n * A reference to a spell, formatted as an image.\n */\nclass SpellLink extends Component<{spell: Spell}, {}> {\n    render() {\n        const hoverOptions = {\n            followCursor: false,\n            shiftX: 20,\n            shiftY: 0\n        };\n        let spellLink = `/spell/${getSpellId(this.props.spell)}`;\n        let className = `SpellLinkThumbnail SpellLinkThumbnail-${this.props.spell.school}`;\n        let linkImage = <Link className=\"SpellLink\" to={spellLink}>\n                <img className={className} src={getSpellThumbnailUrl(this.props.spell)} alt=\"\" />\n                <div>{this.props.spell.name}</div>\n            </Link>;\n        if (isMobile) {\n            return <Tilt>{linkImage}</Tilt>;\n        } else {\n            return <ReactHover options={hoverOptions}>\n                    <ReactHover.Trigger type='trigger'>\n                        {linkImage}\n                    </ReactHover.Trigger>\n                    <ReactHover.Hover type='hover'>\n                        <div className=\"ExtraSpellBox\">\n                            <Link className=\"ExtraSpellLink\" to={spellLink}>\n                                <SpellCard spell={this.props.spell} hide_links />\n                            </Link>\n                        </div>\n                    </ReactHover.Hover>\n                </ReactHover>;\n        }\n    }\n}\n\nexport default SpellLink;\n","import React, { Component } from \"react\";\nimport { Spell, spellsByLevel, spellsBySchool } from \"./model/spell\";\nimport { isFirefox } from \"react-device-detect\";\nimport \"./Spellbook.css\";\nimport \"./hr.css\";\nimport SpellLink from \"./SpellLink\";\nimport LazyLoad from \"react-lazyload\";\n\n/**\n * A component that displays a sequence of spells.\n */\nclass Spellbook extends Component<{ spells: Spell[] }, any> {\n    render() {\n        let headerClass = \"SpellSchoolHeader Sideways\" + (isFirefox ? \"Firefox\" : \"Other\");\n        let elems = [];\n        for (let { level, spells: levelSpells } of spellsByLevel(this.props.spells)) {\n            let levelName = level === \"cantrip\" ? \"Cantrips\" : `Level ${level} spells`;\n            elems.push(<div className=\"LevelHeader\">{levelName}</div>);\n\n            let spellListItems: JSX.Element[] = [];\n            for (let { school, spells } of spellsBySchool(levelSpells)) {\n                let first = true;\n                for (let spell of spells) {\n                    let item = <div key={spell.name} className=\"SpellListItem\">\n                        <LazyLoad height={80} once><SpellLink spell={spell}/></LazyLoad>\n                    </div>;\n                    if (first) {\n                        // Include header in a spell list item, so that the header\n                        // won't get placed alone at the end of a line.\n                        spellListItems.push(<div key={spell.name + '-first'} className=\"FirstSpellListItem\">\n                            <div className={headerClass}>{school}</div>\n                            {item}\n                        </div>);\n                        first = false;\n                    } else {\n                        spellListItems.push(item);\n                    }\n                }\n            }\n            elems.push(<div className=\"SpellList\">{spellListItems}</div>);\n        }\n        return <div className=\"SpellbookPanel\">{elems}</div>;\n    }\n}\n\nexport default Spellbook;\n","import React, { Component } from \"react\";\nimport { Spell, Class, allClasses } from \"./model/spell\";\nimport Spellbook from \"./Spellbook\";\nimport { ToggleButtonGroup, ToggleButton } from \"react-bootstrap\";\nimport \"./FilterableSpellbook.css\";\n\ntype Props = { spells: Spell[] };\ntype State = {\n    classes: Class[]\n};\n\n// TODO: avoid updating local storage here as it breaks composability.\n// Use callbacks instead.\nconst localStorageKey = \"spellbook-filter-state\";\n\nclass FilterableSpellbook extends Component<Props, State> {\n    constructor(props: Props) {\n        super(props);\n        let savedState = localStorage.getItem(localStorageKey);\n        if (savedState) {\n            this.state = JSON.parse(savedState);\n        } else {\n            this.state = {\n                classes: []\n            };\n        }\n    }\n\n    updateClasses(values: Class[]) {\n        this.setState({\n            ...this.state,\n            classes: values\n        }, () => {\n            localStorage.setItem(\"spellbook-filter-state\", JSON.stringify(this.state));\n        });\n    }\n\n    toggleClass(key: Class, value: boolean[]) {\n        let newClasses = this.state.classes.filter(x => x !== key);\n        if (value.includes(true)) {\n            newClasses.push(key);\n        }\n        this.updateClasses(newClasses);\n    }\n\n    getFilteredSpells(): Spell[] {\n        return this.props.spells.filter(val =>\n            this.state.classes.length === 0\n            || val.classes.some(c => this.state.classes.includes(c)));\n    }\n\n    render() {\n        let usefulClasses = allClasses\n            .filter(c => this.props.spells.some(s => s.classes.includes(c)));\n        return <div>\n            {usefulClasses.map(c =>\n                    <ToggleButtonGroup type=\"checkbox\" value={[this.state.classes.includes(c)]} onChange={(vals: any) => this.toggleClass(c, vals)}>\n                        <ToggleButton className=\"ClassButton\" value={true}>\n                            <div className=\"ClassButtonPanel\">\n                                <div className=\"ClassImageBorder\">\n                                    <img className=\"ClassThumbnail\" src={`images/classes/${c}.svg`} alt=\"\"/>\n                                </div>\n                                {c}\n                            </div>\n                        </ToggleButton>\n                    </ToggleButtonGroup>)}\n            <Spellbook spells={this.getFilteredSpells()}/>\n        </div>;\n    }\n}\n\nexport default FilterableSpellbook;\n","import React, { Component } from 'react';\nimport { Route, HashRouter } from 'react-router-dom';\nimport './App.css';\nimport { Spell, getSpellId } from './model/spell';\nimport SpellCard from './SpellCard';\nimport FilterableSpellbook from './FilterableSpellbook';\n\nlet allSpells: Spell[] = [];\n\nclass App extends Component<{}, Spell[]> {\n  constructor(props: {}) {\n    super(props);\n    this.state = allSpells;\n  }\n\n  componentDidMount() {\n    // Fetch spell database.\n    fetch(\"data/spells.json\")\n    .then(response => response.json())\n    .then(json => {\n      allSpells = json;\n      this.setState(json);\n    });\n  }\n\n  render() {\n    return (\n      <HashRouter>\n        <div className=\"App\">\n          <header className=\"App-header\">\n            <Route exact={true} path=\"/\" component={MainScreenRouter} />\n            <Route path=\"/spell/:spellId\" component={SpellRoute} />\n          </header>\n        </div>\n      </HashRouter>\n    );\n  }\n}\n\nclass MainScreenRouter extends Component<{ match: any }, any> {\n  render() {\n    return <div>\n      <h1 className=\"AppTitle\">Spellbook</h1>\n      <FilterableSpellbook spells={allSpells}/>\n    </div>;\n  }\n}\n\nclass SpellRoute extends Component<{ match: any }, any> {\n  render() {\n    if (allSpells.length === 0) {\n      return <div></div>;\n    }\n    let spell = allSpells.find(val => getSpellId(val) === this.props.match.params.spellId);\n    if (spell) {\n      return <div className=\"SpellCardBox\"><SpellCard spell={spell} /></div>;\n    } else {\n      let thumbStyle = {width: \"30px\", height: \"30px\"};\n      return <div>\n        <img style={{...thumbStyle, transform: \"scaleX(-1)\"}} src=\"images/classes/wizard.svg\" alt=\"\" />\n        <img style={thumbStyle} src=\"images/classes/warlock.svg\" alt=\"\" />\n        <img style={thumbStyle} src=\"images/classes/wizard.svg\" alt=\"\" />\n        <h1>Error 404</h1>\n        Spell with ID '{this.props.match.params.spellId}' not found.\n      </div>;\n    }\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}